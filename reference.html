---
---
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>TinyMockJS Reference</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="syntax.css">
  </head>
    
  <body class="reference">
    
    <nav class="common">
      <ul>
        <li><a href="index.html">TinyMockJS</a></li>
        <li><a href="installation.html">Installation</a></li>
        <li><a href="tutorial.html">Tutorial</a></li>
        <li><a href="reference.html">Reference</a></li>
        <li><a href="https://github.com/milewgit/TinyMockJS">Source</a></li>
      </ul>
    </nav>
      
    <section>
      
      <header>
        <h1>Reference</h1>
      </header>
      
      <article>
        <ul class="images">
        
          <li>
            <p class="usage">
              <a name="args" href="#args">args(arg [, arg, ...])</a>
            </p>
            <p>
              Specifies the arguments of an expected method call.  For example, the following creates
              the expectation that the method appendFileSync() will be called with the arguments 
              "log.txt" and "This is a log entry.":
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  fs.expects("appendFileSync").args("log.txt", "This is a log entry.")
{% endhighlight %}</pre>
            <p>
              args() should be called with one or more arguments.  Do not use args() if an expected 
              method is to be called with no arguments:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("close")           # ok; no arguments expected (e.g. socket.close() )
  socket.expects("close").args()    # not ok; do not use args() with no arguments
{% endhighlight %}</pre>              
            <p>
              args() should only be called once per expectation:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  fs.expects("appendFileSync").args("l.txt", "x")                         # ok
  fs.expects("appendFileSync").args("l.txt").args("x")                    # not ok
  fs.expects("appendFileSync").args("l1.txt", "x1").args("l2.txt", "x2")  # not ok ...
  fs.expects("appendFileSync").args("l1.txt", "x1")                       # ... do this instead
  fs.expects("appendFileSync").args("l2.txt", "x2")
{% endhighlight %}</pre>
            <p>
              args() returns an expectation upon which either returns() or throws() can be
              called.  args() should not be called after returns() or throws():
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("greet").args("hello").returns("hi")     # ok
  socket.expects("greet").returns("hi").args("hello")     # not ok
  socket.expects("greet").args(null).throws("error")      # ok
  socket.expects("greet").throws("error").args(null)      # not ok
{% endhighlight %}</pre>
            <p>
              Example:
            </p>
            <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("TinyMockJS").mock
Chat   = require("../src/Chat").Chat

describe "Chat", ->
  describe "greet(my_name)", ->
    it "sends a greeting and returns the response", ->
      mock (socket) ->
        socket.expects("write")</span>.args("Hello, my name is Aristotle.\n")<span class="dim">
        socket.expects("read").returns("Greetings Aristotle!\n")
        chat = new Chat(socket)
        chat.greet("Aristotle").should.equal("Greetings Aristotle!\n")</span></pre>
          </li>
        
        
          <li>
            <p class="usage">
              <a name="expects" href="#expects">object.expects(method_name)</a>
            </p>
            <p>
              Creates an expectation that method_name will be called on object.  For example, the following 
              creates the expectation that the method appendFileSync() will be called on the object fs:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  fs.expects("appendFileSync"){% endhighlight %}</pre>
            <p>
              expects() can be called on any class, on any instance of Object, or on anything that inherits from Object:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  Object.expects("toString")      # Object is a class
  
class MyClass
  # empty
mock ->
  MyClass.expects("toString")     # any class that inherits from Object (i.e. any class)
              
mock ->
  object = new Object()
  object.expects("toString")      # object is an instance of Object
  
class MyClass
  # empty
mock ->
  object = new MyClass()
  object.expects("toString")      # object is an instance of MyClass, which inherits from Object

mock ->
  object = Object.create(null);
  object.expects("my_method")     # not ok; object has no method 'expects'{% endhighlight %}</pre>
            <p>
              method_name must already exist unless expects() is called on a mock instance passed in by mock():
            </p>
            <pre class="code">{% highlight coffeescript %}
class MyClass
  # empty
mock ->
  MyClass.expects("my_method")    # not ok; my_method() is not an existing method of MyClass

class MyClass
  # empty
mock ->
  object = new MyClass()
  object.expects("my_method")     # not ok; my_method() is not an existing method of MyClass

mock (object) ->
  object.expects("my_method")     # ok; object was passed in by mock(){% endhighlight %}</pre>
            <p>
              expects() replaces an existing method_name with a mock method, therefore the original method_name's
              functionality is 'lost':
            </p>
            <pre class="code">{% highlight coffeescript %}
class MyObject
  my_method: -> console.log("hello")
mock ->
  object = new MyObject()
  object.my_method()              # prints "hello" on the console
  object.expects("my_method")
  object.my_method()              # does nothing

mock (object) ->
  object.my_method()              # not ok: throws an unknown method error
  object.expects("my_method")
  object.my_method()              # ok (but does nothing)
{% endhighlight %}</pre>
            <p>
              expects() returns an expectation object upon which the args(), returns(), or throws() methods can be called.
              This allows for method chaining:
            </p>
            <pre class="code">{% highlight coffeescript %}
my_object.expects("my_method").args(1,2,3).returns("something")
{% endhighlight %}</pre>
            <p>
              Example:
            </p>
            <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("TinyMockJS").mock
Chat   = require("../src/Chat").Chat

describe "Chat", ->
  describe "greet(my_name)", ->
    it "sends a greeting and returns the response", ->
      mock (socket) ->
        socket</span>.expects("write")<span class="dim">.args("Hello, my name is Aristotle.\n")
        socket</span>.expects("read")<span class="dim">.returns("Greetings Aristotle!\n")
        chat = new Chat(socket)
        chat.greet("Aristotle").should.equal("Greetings Aristotle!\n")</span></pre>
          </li>
        
        
          <li>
            <p class="usage">
              <a name="mock" href="#mock">mock [options,] callback</a>
            </p>
            <p>
              Use mock() to run a callback function that sets expectations and runs tests:
            </p>
            <pre class="code">{% highlight coffeescript %}describe "greet(name)", ->
  mock
    ->                                  # callback function
      fs.expects("appendFileSync")      # set an expectation
      chat = new Chat()
      chat.greet("Aristotle")           # run a test that should call fs.appendFileSync(){% endhighlight %}</pre>
            <p>
              mock() adds expects() to Object.prototype so that you can add an expectation on anything that is an instance
              of Object or that inherits from Object.  When the callback function finishes running, mock() verifies that all 
              expectations were actually met.
            </p>
          </li>
        
        
          <li>
            <p class="usage">
              <a name="require" href="#require">require</a>
            </p>
            <p>
              Use the Node.js <a href="http://openmymind.net/2012/2/3/Node-Require-and-Exports/">require()</a> 
              function as follows to include TinyMockJS in your code:
            </p>
            <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()</span>
mock   = require("TinyMockJS").mock
<span class="dim">Chat   = require("../src/Chat").Chat

describe "Chat", ->
  describe "greet(my_name)", ->
    it "sends a greeting and returns the response", ->
      mock (socket) ->
        socket.expects("write").args("Hello, my name is Aristotle.\n")
        socket.expects("read").returns("Greetings Aristotle!\n")
        chat = new Chat(socket)
        chat.greet("Aristotle").should.equal("Greetings Aristotle!\n")</span></pre>
          </li>
        
        
          <li>
            <p class="usage">
              <a name="returns" href="#returns">returns(value)</a>
            </p>
            <p>
              Specifies the value that a mock method installed by an expectation should return.  For
              example, the following creates an expectation for the method read() and that the 
              mock read() installed by the expectation should return "a message":
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("read").returns("a message")
{% endhighlight %}</pre>
            <p>
              returns() should be called with one argument.  Do not use returns() if the mocked 
              method should not return anything:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("close")             # ok; mocked close() does not return anything
  socket.expects("close").returns()   # not ok; do not use returns() with no arguments
{% endhighlight %}</pre>
            <p>
              returns() should only be called once per expectation:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("read").returns("a message")           # ok
  socket.expects("read").returns("m1").returns("m2")    # not ok
  
mock ->
  socket.expects("read").returns("m1")
  socket.expects("read").returns("m2")                  # not ok; TinyMockJS cannot handle this  
{% endhighlight %}</pre>
          <p>
            returns() and throws() cannot be used on the same expectation:
          </p>
          <pre class="code">{% highlight coffeescript %}
mock ->
  socket.expects("read").throws("an error").returns("a message")    # not ok
{% endhighlight %}</pre>
            <p>
              Example:
            </p>
            <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("TinyMockJS").mock
Chat   = require("../src/Chat").Chat

describe "Chat", ->
  describe "greet(my_name)", ->
    it "sends a greeting and returns the response", ->
      mock (socket) ->
        socket.expects("write").args("Hello, my name is Aristotle.\n")
        socket.expects("read")</span>.returns("Greetings Aristotle!\n")<span class="dim">
        chat = new Chat(socket)
        chat.greet("Aristotle").should.equal("Greetings Aristotle!\n")</span></pre>
          </li>
        
        
          <li>
            <p class="usage">
              <a name="throws" href="#throws">throws(error)</a>
            </p>
            <p>
              Specifies the error that a mock method installed by an expectation should throw.  For
              example, the following creates an expectation for the method read() and that the 
              mock read() installed by the expectation should throw "an error":
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("read").throws(new Error("an error"))
{% endhighlight %}</pre>
            <p>
              throws() should be called with one argument.  Do not use throws() if the mocked 
              method should not throw anything:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("close")             # ok; mocked close() does not throw anything
  socket.expects("close").throws()    # not ok; do not use throws() with no arguments
{% endhighlight %}</pre>
            <p>
              throws() should only be called once per expectation:
            </p>
            <pre class="code">{% highlight coffeescript %}
mock ->
  socket = new Socket()
  socket.expects("read").throws("e")                  # ok
  socket.expects("read").throws("e1").throws("e2")    # not ok
  
mock ->
  socket.expects("read").throws("e1")
  socket.expects("read").throws("e2")                 # not ok; TinyMockJS cannot handle this  
{% endhighlight %}</pre>
          <p>
            throws() and returns() cannot be used on the same expectation:
          </p>
          <pre class="code">{% highlight coffeescript %}
mock ->
  socket.expects("read").returns("a message").throws("an error")    # not ok
{% endhighlight %}</pre>
            <p>
              Example:
            </p>
            <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("TinyMockJS").mock
Chat   = require("../src/Chat").Chat

describe "Chat", ->
  describe "greet(my_name)", ->
    it "sends a greeting and returns the response", ->
      mock (socket) ->
        socket.expects("write").args("Hello, my name is Aristotle.\n")
        socket.expects("read")</span>.throws(new Error("socket read error"))<span class="dim">
        chat = new Chat(socket)
        (-> chat.greet("Aristotle") ).should.throw("socket read error\n")</span></pre>


          </li>
        </ul>
      </article>
    </section>
    
    <footer>
      <article>
        &copy; 2014 milewgit
      </article>
    </footer>

  </body>  
</html>
