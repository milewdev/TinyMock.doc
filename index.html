---
---
<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>TinyMockJS</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="syntax.css">
  </head>
    
  <body>
    <div class="page-body-content fixed-width-800px">
      <section>
        
        
        <article>  
          <header><h1><a name="what-is-it" href="#what-is-it">What is TinyMockJS?</a></h1></header>
          <p>
            TinyMockJS is a very small <a href="http://coffeescript.org">coffeescript</a> 
            <a href="http://en.wikipedia.org/wiki/Mock_object">mocking</a> framework. &nbsp; For example:
          </p>
          <pre class="code">
{% highlight coffeescript %}
chai   = require("chai")
should = chai.should()
mock   = require("TinyMockJS").mock

class Sut
  @run: (adder, x, y, z)->
    adder.add(x, y, z)
    
describe "Sut.run(adder, x, y, z)", ->
  it "invokes adder.add() to add x, y, and z and returns the result", ->
    mock (mocked_adder) ->
      mocked_adder.expects("add").args(1, 2, 3).returns(6)
      Sut.run(mocked_adder, 1, 2, 3).should.equal(6)
{% endhighlight %}</pre>
        </article>
        
        
        <article>
          <header><h1><a name="#installation" href="#installation">Installation</a></h1></header>
          
          <p>
            <h2>Requirements:</h2>
          </p>
          <ul>
            <li><a href="http://nodejs.org">Node.js</a></li>
            <li>A testing framework, such as <a href="http://visionmedia.github.io/mocha/">mocha</a> and <a href="http://chaijs.com">chai</a>.</li>
          </ul>
          
          <p>
            <h2>Install:</h2>
            ?
          </p>
          
          <p>
            <h2>Uninstall:</h2>
            ?
          </p>
          
        </article>

        <article>
          <header><h1><a name="#tutorial" href="#tutorial">Tutorial</a></h1></header>
          <ol class="steps">
            
            <li value="0">
              <p>
              We'll write a simplistic Logger class to get a sense of how to use TinyMockJS in a project.
              We'll write our code in coffeescript, we'll use <a href="http://nodejs.org">Node.js</a> to run it, 
              and we'll use <a href="http://visionmedia.github.io/mocha/">mocha</a> and <a href="http://chaijs.com">chai</a> 
              for our testing framework.  
              </p>
              <p>
              Ensure that you have <a href="http://nodejs.org">Node.js</a> installed 
              before proceeding; mocha, chai, and coffeescript will be installed in the steps below.
              </p>
              <p>
              Note that all of the files for this tutorial can be found <a href="#TODO">here</a>.
              </p>
            </li>
            
            <li>
              Create a project directory, and create subdirectories for source code and test code files:
              <pre class="code">$ mkdir -p ~/tutorial/src ~/tutorial/test
$ cd ~/tutorial</pre>
            </li>
            
            <li>
              Use your favorite editor to create a minimal Cakefile that uses mocha to run our tests:
              <pre class="code">
{% highlight coffeescript %}
{exec} = require 'child_process'

task 'test', 'Run unit tests', ->
  exec 'mocha
      --compilers coffee:coffee-script
      --require coffee-script
      --reporter spec
      --colors', (err, stdout, stderr) ->
    throw err if err
    console.log stdout + stderr
{% endhighlight %}</pre>
            </li>
            
            <li>
              Also create a minimal package.json:
              <pre class="code">
{% highlight json %}
{
  "name": "TinyMockJS",
  "scripts": {
    "test": "cake test"
  },
  "devDependencies": {
    "mocha": "*",
    "chai": "*",
    "coffee-script": "~1.6"
  }
}
{% endhighlight %}</pre>
            </li>
            
            <li>
              Use npm to install mocha, chai, and the coffee-script compiler:
              <pre class="code">$ npm install
...</pre>
            </li>
            
            <li>
              Create the file test/Logger.test.coffee to contain code for tests; start by requiring chai and mock:
              <pre class="code">
{% highlight coffeescript %}
chai   = require("chai")
should = chai.should()
mock   = require("/Users/vagrant/Documents/TinyMockJS/src/TinyMockJS").mock
Logger = require("../src/Logger").Logger
{% endhighlight %}</pre>
            </li>
            
            <li>
              Add a test for Logger's constructor to test/Logger.test.coffee:
              <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("/Users/vagrant/Documents/TinyMockJS/src/TinyMockJS").mock
Logger = require("../src/Logger").Logger

</span>{% highlight coffeescript %}
describe "Logger", ->
  describe "constructor(options)", ->
    it "retrieves the log file name from 'options'", ->
      mock (options) ->
        options.expects("get_log_filename")
        logger = new Logger(options)
{% endhighlight %}</pre>
              The mock() function takes a function argument.  mock() creates five mock objects and
              then invokes the function argument, passing it the five mocks, which the function can
              then choose to use as it sees fit.  In our code above, we use just one of the mocks
              and we refer to it as 'options'.  Here's how you might use all five mocks:
              <pre class="code">
{% highlight coffeescript %}
mock (store, inventory, book1, book2, customer) ->
  store.expects("get_inventory").returns(inventory)
  inventory.expects("get_books").returns( [book1, book2] )
  customer.expects ...
{% endhighlight %}</pre>
            </li>
            
            <li>
              Run the tests and they fail as we do not yet have a Logger class:
              <pre class="code">$ npm test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test


/Users/vagrant/tutorial/Cakefile:13
        throw err;
              ^
Error: Command failed: 
module.js:340
    throw err;
          ^
Error: Cannot find module '../src/Logger'
    at Function.Module._resolveFilename (module.js:338:15)
      ...</pre>
            </li>
            
            <li>
              Create the source code file src/Logger.coffee; start by implementing the constructor that our test is for:
              <pre class="code">
{% highlight coffeescript %}
class Logger

  constructor: (options) ->
    @log_filename = options.get_log_filename()
    
exports.Logger = Logger
{% endhighlight %}</pre>
            </li>
            
            <li>
              Run the tests again, and this time they pass:
              <pre class="code">$ npm test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test



  Logger
    constructor(options)
      ✓ retrieves the log file name from 'options' 


  1 passing (13ms)

</pre>
            </li>
            
            <li>
              Add a test for a Logger.log() method:
              <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("/Users/vagrant/Documents/TinyMockJS/src/TinyMockJS").mock
Logger = require("../src/Logger").Logger
</span>{% highlight coffeescript %}fs     = require("fs"){% endhighlight %}<span class="dim">
describe "Logger", ->
  describe "constructor(options)", ->
    it "retrieves the log file name from 'options'", ->
      mock (options) ->
        options.expects("get_log_filename")
        logger = new Logger(options)        
          
</span>{% highlight coffeescript %}
  describe "log(message)", ->
    it "writes 'message' to 'log_filename' that was passed to the constructor", ->
      options = { get_log_filename: -> "log.txt" }
      logger = new Logger(options)
      mock ->
        fs.expects("appendFileSync").args("log.txt", "a message")
        logger.log("a message")
{% endhighlight %}</pre>
              This time instead of using one of the mock objects created and passed in by mock(), we use an existing
              object, fs, and specify an expectation on it.
            </li>
            
            <li>
              Run the tests:
              <pre class="code">$ node test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test


/Users/vagrant/tutorial/Cakefile:13
        throw err;
              ^
Error: Command failed:   1 failing

  1) Logger log(message) writes 'message' to 'log_filename' that was passed to the constructor:
     TypeError: Object #<Logger> has no method 'log'
      at /Users/vagrant/tutorial/test/Logger.test.coffee:35:25
      ...
</pre>
            </li>
            
            <li>
              Add the log() method to the Logger class:
              <pre class="code">{% highlight coffeescript %}
fs = require("fs")
{% endhighlight %}<span class="dim">
class Logger

  constructor: (options) ->
    @log_filename = options.get_log_filename()

</span>{% highlight coffeescript %}
  log: (message) ->
    fs.appendFileSync(@log_filename, message)
{% endhighlight %}<span class="dim">
exports.Logger = Logger
</pre>
            </li>
            
            <li>
              Run the tests:
              <pre class="code">$ node test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test



  Logger
    constructor(options)
      ✓ retrieves the log file name from 'options' 
    log(message)
      ✓ writes 'message' to 'log_filename' that was passed to the constructor 


  2 passing (10ms)

</pre>
            </li>
            
            <li>
               log() should not eat exceptions thrown by fs.appendFileSync(), so write another test
              <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("/Users/vagrant/Documents/TinyMockJS/src/TinyMockJS").mock
Logger = require("../src/Logger").Logger
fs     = require("fs")

describe "Logger", ->
  describe "constructor(options)", ->
    it "retrieves the log file name from 'options'", ->
      mock (options) ->
        options.expects("get_log_filename")
        logger = new Logger(options)        
          
  describe "log(message)", ->
    it "writes 'message' to 'log_filename' that was passed to the constructor", ->
      options = { get_log_filename: -> "log.txt" }
      logger = new Logger(options)
      mock ->
        fs.expects("appendFileSync").args("log.txt", "a message")
        logger.log("a message")

</span>{% highlight bash %}
    it "does not eat exceptions thrown by fs.appendFileSync", ->
      options = { get_log_filename: -> "log.txt" }
      logger = new Logger(options)
      mock ->
        fs.expects("appendFileSync").args("log.txt", "a message").throws(new Error("an error"))
        (-> logger.log("a message") ).should.throw("an error")
{% endhighlight %}</pre>
            </li>
            
            <li>
              Run the tests:
              <pre class="code">$ node test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test



  Logger
    constructor(options)
      ✓ retrieves the log file name from 'options' 
    log(message)
      ✓ writes 'message' to 'log_filename' that was passed to the constructor 
      ✓ does not eat exceptions thrown by fs.appendFileSync 


  3 passing (14ms)

</pre>
              They pass, so log() already does not eat exceptions.
            </li>
            
            <li>
              Refactor the tests to remove some duplication:
              <pre class="code"><span class="dim">chai   = require("chai")
should = chai.should()
mock   = require("/Users/vagrant/Documents/TinyMockJS/src/TinyMockJS").mock
Logger = require("../src/Logger").Logger
fs     = require("fs")

describe "Logger", ->
  describe "constructor(options)", ->
    it "retrieves the log file name from 'options'", ->
      mock (options) ->
        options.expects("get_log_filename")
        logger = new Logger(options)        
          
  describe "write(message)", ->
</span>{% highlight bash %}
    
    logger = undefined
    
    beforeEach ->
      options = { get_log_filename: -> "log.txt" }
      logger = new Logger(options)
{% endhighlight %}<span class="dim">
    it "writes 'message' to 'log_filename' that was passed to the constructor", ->
      mock ->
        fs.expects("appendFileSync").args("log.txt", "a message")
        logger.log("a message")

    it "does not eat exceptions thrown by fs.appendFileSync", ->
      mock ->
        fs.expects("appendFileSync").args("log.txt", "a message").throws(new Error("an error"))
        (-> logger.log("a message") ).should.throw("an error")</span></pre>
            </li>
            
            <li>
              Run the tests one last time:
              <pre class="code">$ node test

> TinyMockJS@ test /Users/vagrant/tutorial
> cake test



  Logger
    constructor(options)
      ✓ retrieves the log file name from 'options' 
    write(message)
      ✓ writes 'message' to 'log_filename' that was passed to the constructor 
      ✓ does not eat exceptions thrown by fs.appendFileSync 


  3 passing (17ms)

</pre>
            </li>
            
          </ul>
        </article>
        
        
        <article>
          <header><h1><a name="#reference" href="#reference">Reference</a></h1></header>
          <p>
            TODO
          </p>
        </article>
        
        
      </section>
    </div>
  </body>
  
</html>
